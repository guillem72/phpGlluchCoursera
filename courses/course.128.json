{"id":128,"shortName":"algo2","name":"Algorithms: Design and Analysis, Part 2","language":"en","previewLink":"https:\/\/class.coursera.org\/algo2-003\/lecture\/preview","shortDescription":"In this course you will learn several fundamental principles of advanced algorithm design: greedy algorithms and applications; dynamic programming and applications; NP-completeness and what it means for the algorithm designer; the design and analysis of heuristics; and more.","aboutTheCourse":"<div>In this course you will learn several fundamental principles of advanced algorithm design. You'll learn the greedy algorithm design paradigm, with applications to computing good network backbones (i.e., spanning trees) and good codes for data compression. You'll learn the tricky yet widely applicable dynamic programming algorithm design paradigm, with applications to routing in the Internet and sequencing genome fragments. &nbsp;You\u2019ll learn what NP-completeness and the famous \u201cP vs. NP\u201d problem mean for the algorithm designer. &nbsp;Finally, we\u2019ll study several strategies for dealing with hard (i.e., NP-complete problems), including the design and analysis of heuristics. &nbsp;Learn how shortest-path algorithms from the 1950s (i.e., pre-ARPANET!) govern the way that your Internet traffic gets routed today; why efficient algorithms are fundamental to modern genomics; and how to make a million bucks in prize money by \u201cjust\u201d solving a math problem!<\/div>\n<div><\/div>","targetAudience":1,"courseSyllabus":"<b>Weeks 1 and 2: <\/b>The greedy algorithm design paradigm.&nbsp; Applications to optimal caching and scheduling.&nbsp; Minimum spanning trees and applications to clustering.&nbsp; The union-find data structure.&nbsp; Optimal data compression.<br><br><b>Weeks 3 and 4: <\/b>The dynamic programming design paradigm.&nbsp; Applications to the knapsack problem,&nbsp;sequence alignment, shortest-path routing, and optimal search trees.<br><br><b>Weeks 5 and 6:<\/b> Intractable problems and what to do about them.&nbsp; NP-completeness and the P vs. NP question.&nbsp; Solvable special cases. Heuristics with provable performance guarantees.&nbsp; Local search.&nbsp;Exponential-time algorithms that beat brute-force search.<br>","courseFormat":"<div>The class will consist of lecture videos, generally between 10 and 15 minutes in length. These usually have integrated quiz questions. There will also be standalone homeworks and programming assignments that are not part of video lectures, and a final exam.<\/div>\n<div><\/div>","suggestedReadings":"No specific textbook is required for the course.&nbsp; Much of the course material is covered by the well-known textbooks on algorithms, and the student is encouraged to consult their favorite for additional information.<br><br><br>","instructor":"Tim Roughgarden","estimatedClassWorkload":"6-10 hours\/week","recommendedBackground":"<div>How to program in at least one programming language (like C, Java, or Python); and familiarity with proofs, including proofs by induction and by contradiction. &nbsp;At Stanford, a version of this course is taken by sophomore, junior, and senior-level computer science majors. &nbsp;The course assumes familiarity with some of&nbsp;the topics from <a href=\"https:\/\/www.coursera.org\/course\/algo\">Algo 1<\/a>&nbsp;--- especially asymptotic analysis, basic data structures, and basic graph algorithms.<\/div>\n<div><\/div><br>","links":{}}