{"id":14,"shortName":"automata","name":"Automata","language":"en","previewLink":"https:\/\/class.coursera.org\/automata\/lecture\/preview","shortDescription":"This course covers finite automata, context-free grammars, Turing machines, undecidable problems, and intractable problems (NP-completeness).","aboutTheCourse":"<p>I am pleased to be able to offer free over the Internet a course on Automata Theory, based on the material I have taught periodically at Stanford in the course CS154. Participants have access to screencast lecture videos, are given quiz questions, assignments and exams, receive regular feedback on progress, and can participate in a discussion forum. Those who successfully complete the course will receive a statement of accomplishment. You will need a decent Internet connection for accessing course materials, but should be able to watch the videos on your smartphone.<\/p>\nThe course covers four broad areas: (1) Finite automata and regular expressions, (2) Context-free grammars, (3) Turing machines and decidability, and (4) the theory of intractability, or NP-complete problems.<br><strong><br>Why Study Automata Theory?<\/strong><br><br>This subject is not just for those planning to enter the field of complexity theory, although it is a good place to start if that is your goal. Rather, the course will emphasize those aspects of the theory that people really use in practice. Finite automata, regular expressions, and context-free grammars are ideas that have stood the test of time. They are essential tools for compilers. But more importantly, they are used in many systems that require input that is less general than a full programming language yet more complex than \"push this button.\"<br><br>The concepts of undecidable problems and intractable problems serve a different purpose. Undecidable problems are those for which no computer solution can ever exist, while intractable problems are those for which there is strong evidence that, although they can be solved by a computer, they cannot be solved sufficiently fast that the solution is truly useful in practice. Understanding this theory, and in particular being able to prove that a problem you are facing belongs to one of these classes, allows you to justify taking another approach \u2014 simplifying the problem or writing code to approximate the solution, for example.<br><br>During the course, I'm going to prove a number of things. The purpose of these proofs is not to torture you or confuse you. Neither are the proofs there because I doubt you would believe me were I merely to state some well-known fact. Rather, understanding how these proofs, especially inductive proofs, work, lets you think more clearly about your own work. I do not advocate proofs that programs are correct, but whenever you attempt something a bit complex, it is good to have in mind the inductive proofs that would be needed to guarantee that what you are doing really works in all cases.","targetAudience":1,"courseSyllabus":"Week 1: Finite Automata<br>Week 2: Regular Expressions and Properties of Regular Languages<br>Week 3: Context-Free Grammars and Languages<br>Week 4: Properties of Context-Free Languages, plus introduction to Turing Machines<br>Week 5: Turing Machines and Undecidability<br>Week 6: Intractable Problems (NP-Completeness)","courseFormat":"3-4 lecture videos each week. \u00a0Many of these videos are longer than the typical MOOC video, so feel free to pause them and view them in several sessions of your own choice.<br><br>There will be 1-2 problem sets each week, which together count for 50% of the marks. \u00a0You can repeat them until you get them all correct, and they are due two Mondays after release of the videos on which they are based.<br><br>There are also two optional programming challenges.","suggestedReadings":"The course is built around the material in <a href=\"http:\/\/chggtrx.com\/click.track?CID=267582&AFID=301076&ADID=1088031&SID=automata&isbn_ean=9780321455369\" target=\"_blank\">Automata Theory, Languages, and Computation 3rd edition<\/a> (2007), by John Hopcroft, Rajeev Motwani, and Jeffrey Ullman, Addison-Wesley. However, you do not have to buy a copy of this book. The course is self-contained, and all homeworks and exams are based solely on concepts taught in the video lectures.","instructor":"Jeffrey Ullman, Professor","estimatedClassWorkload":"8-10 hours\/week","recommendedBackground":"<p>You should have had a second course in Computer Science \u2014 one that covers basic data structures (e.g., lists, trees, hashing), and basic algorithms (e.g., tree traversals, recursive programming, big-oh running time). In addition, a course in discrete mathematics covering propositional logic, graphs, and inductive proofs is valuable background.<\/p>\n<p>If you need to review or learn some of these topics, there is a free on-line textbook Foundations of Computer Science, written by Al Aho and me, available at\u00a0<a href=\"http:\/\/i.Stanford.edu\/~ullman\/focs.html\">http:\/\/i.stanford.edu\/~ullman\/focs.html<\/a>. Recommended chapters include 2 (Recursion and Induction), 3 (Running Time of Programs), 5 (Trees), 6 (Lists), 7 (Sets), 9 (Graphs), and 12 (Propositional Logic). You will also find introductions to finite automata, regular expressions, and context-free grammars in Chapters 10 and 11. Reading Chapter 10 would be good preparation for the first week of the course.<\/p>\n<p>The course includes two programming exercises for which a knowledge of Java or Python\u00a0is required. However, these exercises are optional. You will receive automated feedback, but the results will not be recorded or used to grade the course. So if you are familiar with neither\u00a0Java nor Python, you can still take the course without concern for prerequisites.<\/p>","links":{}}